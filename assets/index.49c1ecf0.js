export default"# Using Utils Package\n\nWe provide a [util package](https://www.npmjs.com/package/@milkdown/utils) to provide more abilities and convenience when writing plugins.\n\n# Factory\n\nThe util package provides three factory functions:\n\n-   _createProsePlugin_:\n    Create a [prosemirror plugin](https://prosemirror.net/docs/ref/#state.Plugin_System).\n-   _createNode_:\n    Create a [prosemirror node](https://prosemirror.net/docs/ref/#model.Node).\n-   _createMark_:\n    Create a [prosemirror mark](https://prosemirror.net/docs/ref/#model.Mark).\n\n## Options\n\nSome times you may want the plugins can be configured with different options.\nWith factories provided in util package, you can easily implement this:\n\n```typescript\nimport { createProsePlugin } from '@milkdown/utils';\nimport { Plugin } from '@milkdown/prose';\n\ntype Options = {\n    color: string;\n};\n\nexport const myProsemirrorPlugin = createProsePlugin<Options>((options) => {\n    // All options must have a default value.\n    const color = options?.color ?? '#fff';\n\n    return new Plugin({\n        // ...define your plugin\n    });\n});\n\n// Usage:\n// Default\nEditor.use(myProsemirrorPlugin());\n\n// Custom Config\nEditor.use(myProsemirrorPlugin({ color: '#000' }));\n```\n\n## Utils\n\nWe provide some utils to make build features more easily.\n\n### getStyle\n\nWith the `getStyle` function, you can:\n\n-   Access the design system through [themeTool]().\n-   Make your style adapt the **headless mode**.\n\n```typescript\nimport { createProsePlugin } from '@milkdown/utils';\nimport { Plugin } from '@milkdown/prose';\nimport { css } from '@emotion/css';\n\ntype Options = {\n    color: string;\n};\n\nexport const myProsemirrorPlugin = createProsePlugin((_, utils) => {\n    const className = utils.getStyle((themeTool) => {\n        const primaryColor = themeTool.palette('primary');\n        const { shadow } = themeTool.mixin;\n\n        return css`\n            ${shadow};\n            color: ${primaryColor};\n        `;\n    });\n\n    return new Plugin({\n        // ...define your plugin\n    });\n});\n\n// Headless mode:\n// In headless mode, style created by `getStyle` will be disabled.\nEditor.use(myProsemirrorPlugin({ headless: true }));\n```\n\n### getClassName\n\nThe `getClassName` function is a shortcut for users to create class name.\n\n```typescript\nimport { createNode } from '@milkdown/utils';\n\nexport const myNode = createNode<Keys>((options, utils) => {\n    const id = 'myNode';\n    const style = 'my-class-name';\n\n    return {\n        id,\n        schema: {\n            content: 'inline*',\n            group: 'block',\n            parseDOM: [{ tag: 'div' }],\n            toDOM: (node) => ['div', { class: utils.getClassName(node.attrs, id, style) }, 0],\n        },\n        // ...other props\n    };\n});\n```\n\nIn the example above, by default, the generated block will be a `div` element with the className: `myNode my-class-name`. Users can also add custom class name by options:\n\n```typescript\nEditor.use(\n    myNode({\n        className: (attrs) => ['my-custom-node-className', attrs.disabled && 'disabled'],\n    }),\n);\n```\n\n### ctx\n\nYou can also get the editor _ctx_.\n\n```typescript\nimport { rootCtx } from '@milkdown/core';\nimport { createProsePlugin } from '@milkdown/utils';\n\nexport const myProsemirrorPlugin = createProsePlugin((_, utils) => {\n    const { ctx } = utils;\n    const getRootElement = () => ctx.get(rootCtx);\n\n    return new Plugin({\n        // ...define your plugin\n        // Get root element\n        const rootElement = getRootElement();\n    });\n});\n```\n\n## Commands and Shortcuts\n\nIn **node and mark**, define commands and shortcuts are much easier.\n\nFor example in heading node:\n\n```typescript\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { createNode, createShortcut } from '@milkdown/utils';\nimport { setBlockType } from '@milkdown/prose';\n\ntype Keys = 'H1' | 'H2' | 'H3';\n\nexport const TurnIntoHeading = createCmdKey<number>();\nexport const heading = createNode<Keys>((_, utils) => {\n    const id = 'heading';\n\n    return {\n        id,\n        schema: {\n            content: 'inline*',\n            group: 'block',\n            attrs: {\n                level: {\n                    default: 1,\n                },\n            },\n            parseDOM: [1, 2, 3].map((x) => ({ tag: `h${x}`, attrs: { level: x } })),\n            toDOM: (node) => [`h${node.attrs.level}`, 0],\n        },\n        // ...some other props\n\n        // Implement the commands\n        commands: (nodeType) => [createCmd(TurnIntoHeading, (level = 1) => setBlockType(nodeType, { level }))],\n\n        // Map the commands to keys\n        shortcuts: {\n            [SupportedKeys.H1]: createShortcut(TurnIntoHeading, 'Mod-Alt-1', 1),\n            [SupportedKeys.H2]: createShortcut(TurnIntoHeading, 'Mod-Alt-2', 2),\n            [SupportedKeys.H3]: createShortcut(TurnIntoHeading, 'Mod-Alt-3', 3),\n        },\n    };\n});\n```\n\nIn this example, we use `createCmdKey` to register a command, and use `createCmd` to implement it.\nThe type variable `number` means this command can be called with a `number` as parameter.\nAnd then, we can use the command to create shortcuts.\n\nWith this pattern, we also provides the ability to remap these shortcuts.\n\n```typescript\nEditor.use(\n    heading({\n        keymap: {\n            H1: 'Mod-shift-1',\n            H2: 'Mod-shift-2',\n            H3: 'Mod-shift-3',\n        },\n    }),\n);\n```\n\nYou may notice the `Keys` type we defined, that's used to tell typescript the shortcuts the node or mark support.\nIf users provide a keymap out of scope, the typescript will let them know:\n\n```typescript\nEditor.use(\n    heading({\n        keymap: {\n            // Throw an error when compiled by typescript.\n            H4: 'Mod-shift-4',\n        },\n    }),\n);\n```\n\n# AtomList\n\nIn the real world, a package always composed by a series of milkdown plugins.\n`AtomList` can help users to use and configure a list of plugins more easily.\n\n```typescript\nimport { createNode, AtomList } from '@milkdown/utils';\nconst node1 = createNode(/* node1 */);\nconst node2 = createNode(/* node2 */);\nconst node3 = createNode(/* node3 */);\n\nconst mySyntaxPlugin = AtomList.create([node1(), node2(), node3()]);\n\nEditor.use(mySyntaxPlugin);\n\n// With configure:\nEditor.use(\n    mySyntaxPlugin.configure(node1, {\n        keymap: {\n            //...\n        },\n    }),\n);\n// Equal to:\nEditor.use([\n    node1({\n        keymap: {\n            //...\n        },\n    }),\n    node2(),\n    node3(),\n]);\n\n// Enable headless mode for all:\nEditor.use(mySyntaxPlugin.headless());\n\n// Remove one plugin:\nEditor.use(mySyntaxPlugin.remove(node1));\n\n// Replace one plugin:\nconst myNode1 = createNode(/* ... */);\nEditor.use(mySyntaxPlugin.replace(node1, myNode1));\n```\n";
