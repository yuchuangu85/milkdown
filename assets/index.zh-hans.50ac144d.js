export default"# 使用工具包\n\n我们提供了一个[工具包](https://www.npmjs.com/package/@milkdown/utils)来为编写插件提供更多的能力和便利。\n\n# 工厂函数\n\n工具包提供了三个工厂函数：\n\n-   _createProsePlugin_:\n    创建[prosemirror plugin](https://prosemirror.net/docs/ref/#state.Plugin_System).\n-   _createNode_:\n    创建[prosemirror node](https://prosemirror.net/docs/ref/#model.Node).\n-   _createMark_:\n    创建[prosemirror mark](https://prosemirror.net/docs/ref/#model.Mark).\n\n## 选项\n\n有时你可能希望插件可以通过不同的选项来配置。\n通过工具包中提供的工厂函数，你可以轻松实现它：\n\n```typescript\nimport { createProsePlugin } from '@milkdown/utils';\nimport { Plugin } from '@milkdown/prose';\n\ntype Options = {\n    color: string;\n};\n\nexport const myProsemirrorPlugin = createProsePlugin<Options>((options) => {\n    // 所有的选项都需要默认值\n    const color = options?.color ?? '#fff';\n\n    return new Plugin({\n        // ...定义你的插件\n    });\n});\n\n// 使用：\n// 默认\nEditor.use(myProsemirrorPlugin());\n\n// 自定义配置\nEditor.use(myProsemirrorPlugin({ color: '#000' }));\n```\n\n## 工具\n\n我们提供了一些工具来让实现功能更加轻松。\n\n### getStyle\n\n通过`getStyle`函数，你可以：\n\n-   通过[themeTool]()访问设计系统。\n-   让你的样式自动适配**无头模式**。\n\n```typescript\nimport { createProsePlugin } from '@milkdown/utils';\nimport { Plugin } from '@milkdown/prose';\nimport { css } from '@emotion/css';\n\ntype Options = {\n    color: string;\n};\n\nexport const myProsemirrorPlugin = createProsePlugin((_, utils) => {\n    const className = utils.getStyle((themeTool) => {\n        const primaryColor = themeTool.palette('primary');\n        const { shadow } = themeTool.mixin;\n\n        return css`\n            ${shadow};\n            color: ${primaryColor};\n        `;\n    });\n\n    return new Plugin({\n        // ...定义你的插件\n    });\n});\n\n// 无头模式：\n// 在无头模式中，通过`getStyle`创建的样式都会被消除。\nEditor.use(myProsemirrorPlugin({ headless: true }));\n```\n\n### getClassName\n\n`getClassName`函数是一个让用户更容易创建 class name 的快捷方式。\n\n```typescript\nimport { createNode } from '@milkdown/utils';\n\nexport const myNode = createNode<Keys>((options, utils) => {\n    const id = 'myNode';\n    const style = 'my-class-name';\n\n    return {\n        id,\n        schema: {\n            content: 'inline*',\n            group: 'block',\n            parseDOM: [{ tag: 'div' }],\n            toDOM: (node) => ['div', { class: utils.getClassName(node.attrs, id, style) }, 0],\n        },\n        // ...other props\n    };\n});\n```\n\n在上述例子中，默认情况下，生成的 block 是一个`div`元素，它拥有类名：`myNode my-class-name`。\n用户也可以通过配置自定义类名：\n\n```typescript\nEditor.use(\n    myNode({\n        className: (attrs) => ['my-custom-node-className', attrs.disabled && 'disabled'],\n    }),\n);\n```\n\n### ctx\n\n你也可以访问编辑器的*ctx*。\n\n```typescript\nimport { rootCtx } from '@milkdown/core';\nimport { createProsePlugin } from '@milkdown/utils';\n\nexport const myProsemirrorPlugin = createProsePlugin((_, utils) => {\n    const { ctx } = utils;\n    const getRootElement = () => ctx.get(rootCtx);\n\n    return new Plugin({\n        // ...define your plugin\n        // Get root element\n        const rootElement = getRootElement();\n    });\n});\n```\n\n## 命令和快捷键\n\n在**node 和 mark**中，定义命令和快捷键会更加简单。\n\n例如在标题节点中：\n\n```typescript\nimport { createCmd, createCmdKey } from '@milkdown/core';\nimport { createNode, createShortcut } from '@milkdown/utils';\nimport { setBlockType } from '@milkdown/prose';\n\ntype Keys = 'H1' | 'H2' | 'H3';\n\nexport const TurnIntoHeading = createCmdKey<number>();\nexport const heading = createNode<Keys>((_, utils) => {\n    const id = 'heading';\n\n    return {\n        id,\n        schema: {\n            content: 'inline*',\n            group: 'block',\n            attrs: {\n                level: {\n                    default: 1,\n                },\n            },\n            parseDOM: [1, 2, 3].map((x) => ({ tag: `h${x}`, attrs: { level: x } })),\n            toDOM: (node) => [`h${node.attrs.level}`, 0],\n        },\n        // ...some other props\n\n        // 实现命令\n        commands: (nodeType) => [createCmd(TurnIntoHeading, (level = 1) => setBlockType(nodeType, { level }))],\n\n        // 将命令映射到快捷键\n        shortcuts: {\n            [SupportedKeys.H1]: createShortcut(TurnIntoHeading, 'Mod-Alt-1', 1),\n            [SupportedKeys.H2]: createShortcut(TurnIntoHeading, 'Mod-Alt-2', 2),\n            [SupportedKeys.H3]: createShortcut(TurnIntoHeading, 'Mod-Alt-3', 3),\n        },\n    };\n});\n```\n\n在这个例子中，我们使用`createCmdKey`来注册命令，然后使用`createCmd`来实现它。\n类型变量中的`number`意味着这个命令被调用时可以接受`number`类型的参数。\n然后，我们可以使用这个命令来创建快捷键。\n\n通过这个模式，我们也提供了自定义快捷键的能力。\n\n```typescript\nEditor.use(\n    heading({\n        keymap: {\n            H1: 'Mod-shift-1',\n            H2: 'Mod-shift-2',\n            H3: 'Mod-shift-3',\n        },\n    }),\n);\n```\n\n你可能注意到了定义的`Keys`类型，它用于告诉 typescript 支持的快捷键。\n如果用户试图自定义超出范围的快捷键，typescript 会告诉他们：\n\n```typescript\nEditor.use(\n    heading({\n        keymap: {\n            // typescript编译时会报错\n            H4: 'Mod-shift-4',\n        },\n    }),\n);\n```\n\n# AtomList\n\n在真实世界中，一个包经常由一系列 milkdown 插件组成。\n`AtomList`可以帮助用户更简单的使用和配置插件列表。\n\n```typescript\nimport { createNode, AtomList } from '@milkdown/utils';\nconst node1 = createNode(/* node1 */);\nconst node2 = createNode(/* node2 */);\nconst node3 = createNode(/* node3 */);\n\nconst mySyntaxPlugin = AtomList.create([node1(), node2(), node3()]);\n\nEditor.use(mySyntaxPlugin);\n\n// 配置插件：\nEditor.use(\n    mySyntaxPlugin.configure(node1, {\n        keymap: {\n            //...\n        },\n    }),\n);\n// 等同于：\nEditor.use([\n    node1({\n        keymap: {\n            //...\n        },\n    }),\n    node2(),\n    node3(),\n]);\n\n// 为所有插件开启无头模式：\nEditor.use(mySyntaxPlugin.headless());\n\n// 移除一个插件：\nEditor.use(mySyntaxPlugin.remove(node1));\n\n// 替换一个插件：\nconst myNode1 = createNode(/* ... */);\nEditor.use(mySyntaxPlugin.replace(node1, myNode1));\n```\n";
